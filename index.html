<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <!-- Adaptation sur mobile -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu de Numéros Français</title>
  <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700&display=swap" rel="stylesheet">
  <style>
    /* Réglages généraux */
    * {
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%);
      font-family: 'Montserrat', sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    .container {
      background: #ffffffcc;
      border-radius: 10px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
      padding: 30px;
      max-width: 600px;
      width: 90%;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #333;
    }
    #menu, #game, #result {
      text-align: center;
      margin-top: 20px;
    }
    #challenge {
      font-size: 1.5em;
      margin: 20px 0;
      color: #444;
    }
    input[type="text"],
    input[type="number"],
    input[type="time"],
    input[type="date"] {
      font-size: 1.2em;
      padding: 10px;
      margin: 5px;
      border: 2px solid #ddd;
      border-radius: 5px;
      width: calc(100% - 24px);
    }
    button {
      font-size: 1em;
      padding: 10px 20px;
      margin: 10px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #ff6f91;
      color: white;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #ff3f6f;
    }
    #timer, #roundInfo, #score {
      font-weight: bold;
      color: #555;
    }
    #feedback {
      margin-top: 15px;
      font-size: 1.2em;
      color: #333;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    table, th, td {
      border: 1px solid #ccc;
    }
    th, td {
      padding: 10px;
      text-align: center;
    }
    th {
      background-color: #ff6f91;
      color: white;
    }
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    /* Styles pour les onglets */
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    .tab-btn {
      background-color: #f0f0f0;
      border: none;
      padding: 10px 20px;
      margin: 0 5px;
      cursor: pointer;
      border-radius: 5px 5px 0 0;
      color: #555;
    }
    .tab-btn.active {
      background-color: #ff6f91;
      color: white;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    /* Styles pour le jeu de dates */
    .date-selector {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    .date-column {
      width: 32%;
    }
    .options-container {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .date-option {
      padding: 8px;
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s;
      margin-bottom: 5px;
      color: #333; /* Darker text color */
      font-weight: 500; /* Make text slightly bolder */
    }
    .date-option.selected {
      background-color: #ff6f91;
      color: white;
    }
    #audio-controls {
      margin-bottom: 20px;
      text-align: center;
    }
    #listen-counter {
      font-size: 0.9em;
      color: #666;
      margin-top: 5px;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Jeu de Numéros Français</h1>
  
  <!-- Menu avec onglets pour les modes de jeu -->
  <div id="menu">
    <div class="tabs">
      <button class="tab-btn active" data-tab="number-game">Nombres</button>
      <button class="tab-btn" data-tab="time-game">Heures</button>
      <button class="tab-btn" data-tab="date-game">Dates</button>
    </div>
    
    <div id="number-game" class="tab-content active">
      <div id="rangeSettings">
        <p>Définissez la gamme des numéros :</p>
        <label for="minValue">Minimum :</label>
        <input type="number" id="minValue" value="1" min="1">
        <label for="maxValue">Maximum :</label>
        <input type="number" id="maxValue" value="2025" min="1">
      </div>
      <p>Lancer le mode : <strong>Écouter et taper</strong></p>
      <button id="startNumberGame">Commencer</button>
    </div>
    
    <div id="time-game" class="tab-content">
      <div id="timeSettings">
        <p>Définissez la plage horaire :</p>
        <label for="startTime">Heure de début :</label>
        <input type="time" id="startTime" value="00:00">
        <label for="endTime">Heure de fin :</label>
        <input type="time" id="endTime" value="23:59">
      </div>
      <p>Lancer le mode : <strong>Écouter l'heure et taper</strong></p>
      <p><em>Entrez l'heure au format 12h sans AM/PM, par exemple: 2:30</em></p>
      <button id="startTimeGame">Commencer</button>
    </div>

    <div id="date-game" class="tab-content">
      <div id="dateSettings">
        <p>Définissez la plage de dates :</p>
        <label for="startDate">Date de début :</label>
        <input type="date" id="startDate" value="1900-01-01">
        <label for="endDate">Date de fin :</label>
        <input type="date" id="endDate" value="2050-12-31">
      </div>
      <p>Lancer le mode : <strong>Écouter la date et sélectionner</strong></p>
      <button id="startDateGame">Commencer</button>
    </div>
  </div>
  
  <!-- Zone du jeu -->
  <div id="game" style="display:none;">
    <div id="roundInfo">Tour : <span id="currentRound">0</span> / 10</div>
    <div id="timer">Temps restant : <span id="timeLeft">15</span> s</div>
    <div id="score">Score : <span id="totalScore">0</span></div>
    <div id="challenge"></div>
    <div id="inputArea"></div>
    <div id="feedback"></div>
    <button id="nextRoundButton" style="display:none;">Suivant</button>
  </div>
  
  <!-- Zone des résultats -->
  <div id="result" style="display:none;"></div>
</div>

<script>
  // Fonction pour demander le mode plein écran (nécessite une interaction utilisateur)
  function requestFullScreen() {
    const el = document.documentElement;
    if (el.requestFullscreen) {
      el.requestFullscreen();
    } else if (el.webkitRequestFullscreen) { // Safari
      el.webkitRequestFullscreen();
    } else if (el.msRequestFullscreen) { // IE11
      el.msRequestFullscreen();
    }
  }
  
  // Variables globales
  let round = 0;
  let totalScore = 0;
  let currentNumber = 0;
  let currentTime = "";
  let currentDate = null;
  let startTime = 0;
  let timerInterval = null;
  const maxRounds = 10;         // 10 tours
  const timeLimit = 15;         // 15 secondes par tour
  let minNumber = 1, maxNumber = 2025;  // Gamme par défaut
  let timeStart = "00:00", timeEnd = "23:59"; // Plage horaire par défaut
  let dateStart = "1900-01-01", dateEnd = "2050-12-31"; // Plage de dates par défaut
  let answerSubmitted = false;  // Pour éviter plusieurs validations par tour
  let roundResults = [];        // Tableau pour stocker le résultat de chaque tour
  let gameMode = "number";      // "number", "time" ou "date"
  
  // Éléments de l'interface
  const menuDiv = document.getElementById("menu");
  const gameDiv = document.getElementById("game");
  const resultDiv = document.getElementById("result");
  const currentRoundSpan = document.getElementById("currentRound");
  const timeLeftSpan = document.getElementById("timeLeft");
  const totalScoreSpan = document.getElementById("totalScore");
  const challengeDiv = document.getElementById("challenge");
  const inputAreaDiv = document.getElementById("inputArea");
  const feedbackDiv = document.getElementById("feedback");
  const nextRoundButton = document.getElementById("nextRoundButton");
  
  // Fonctionnalité des onglets
  document.querySelectorAll('.tab-btn').forEach(button => {
    button.addEventListener('click', () => {
      // Supprimer la classe active de tous les boutons et contenus
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      
      // Ajouter la classe active au bouton cliqué
      button.classList.add('active');
      
      // Afficher le contenu correspondant
      const tabId = button.getAttribute('data-tab');
      document.getElementById(tabId).classList.add('active');
    });
  });
  
  // Mise à jour de la gamme en lisant les valeurs saisies
  function updateRange() {
    const minInput = document.getElementById("minValue");
    const maxInput = document.getElementById("maxValue");
    minNumber = parseInt(minInput.value, 10);
    maxNumber = parseInt(maxInput.value, 10);
    if (isNaN(minNumber) || isNaN(maxNumber) || minNumber < 1 || maxNumber < minNumber) {
      alert("Veuillez saisir une gamme valide (min >= 1 et max >= min).");
      throw new Error("Gamme non valide");
    }
  }
  
  // Mise à jour de la plage horaire
  function updateTimeRange() {
    const startTimeInput = document.getElementById("startTime");
    const endTimeInput = document.getElementById("endTime");
    
    // Fix for Firefox - ensure we get valid time values
    timeStart = startTimeInput.value || startTimeInput.getAttribute('value') || "00:00";
    timeEnd = endTimeInput.value || endTimeInput.getAttribute('value') || "23:59";
    
    // Validate time format (HH:MM)
    const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
    if (!timeRegex.test(timeStart) || !timeRegex.test(timeEnd)) {
      console.warn("Invalid time format detected, using defaults");
      timeStart = "00:00";
      timeEnd = "23:59";
    }
    
    console.log("Time range set to:", timeStart, "-", timeEnd);
  }

  // Mise à jour de la plage de dates
  function updateDateRange() {
    const startDateInput = document.getElementById("startDate");
    const endDateInput = document.getElementById("endDate");
    
    dateStart = startDateInput.value || startDateInput.getAttribute('value') || "1900-01-01";
    dateEnd = endDateInput.value || endDateInput.getAttribute('value') || "2050-12-31";
    
    // Validate date format (YYYY-MM-DD)
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(dateStart) || !dateRegex.test(dateEnd)) {
      console.warn("Invalid date format detected, using defaults");
      dateStart = "1900-01-01";
      dateEnd = "2050-12-31";
    }
    
    console.log("Date range set to:", dateStart, "-", dateEnd);
  }
  
  // Check for time input support when page loads
  document.addEventListener('DOMContentLoaded', function() {
    // Test if browser properly supports time input
    const testTimeInput = document.createElement('input');
    testTimeInput.type = 'time';
    testTimeInput.value = '00:00';
    
    const isTimeInputSupported = testTimeInput.type === 'time' && testTimeInput.value !== '';
    
    // Add fallback for browsers with poor time input support
    if (!isTimeInputSupported) {
      console.warn("Time input may not be fully supported in this browser");
      
      // Set default values directly on the elements
      document.getElementById("startTime").value = "00:00";
      document.getElementById("endTime").value = "23:59";
      
      // Add helper text for Firefox users
      const timeSettings = document.getElementById("timeSettings");
      const helperText = document.createElement('p');
      helperText.innerHTML = "<small><em>Note: Utilisez le format 24h (HH:MM) si le sélecteur ne fonctionne pas.</em></small>";
      helperText.style.color = "#666";
      timeSettings.appendChild(helperText);
    }
  });

  // Démarrage de la partie
  document.getElementById("startNumberGame").addEventListener("click", function() {
    gameMode = "number";
    updateRange();
    if (window.innerWidth < 600) {
      requestFullScreen();
    }
    startGame();
  });
  
  document.getElementById("startTimeGame").addEventListener("click", function() {
    gameMode = "time";
    updateTimeRange();
    if (window.innerWidth < 600) {
      requestFullScreen();
    }
    startGame();
  });

  document.getElementById("startDateGame").addEventListener("click", function() {
    gameMode = "date";
    updateDateRange();
    if (window.innerWidth < 600) {
      requestFullScreen();
    }
    startGame();
  });
  
  function startGame() {
    round = 0;
    totalScore = 0;
    roundResults = [];
    totalScoreSpan.textContent = totalScore;
    menuDiv.style.display = "none";
    gameDiv.style.display = "block";
    resultDiv.style.display = "none";
    nextRoundButton.style.display = "none";
    feedbackDiv.textContent = "";
    nextRound();
  }
  
  // Lancement du tour suivant
  function nextRound() {
    // Remove the event listener for Enter key
    document.removeEventListener("keydown", handleNextRoundKeyPress);

    round++;
    answerSubmitted = false;  // Réinitialiser pour ce tour
    if (round > maxRounds) {
      gameOver();
      return;
    }
    currentRoundSpan.textContent = round;
    challengeDiv.textContent = "";
    inputAreaDiv.innerHTML = "";
    feedbackDiv.textContent = "";
    nextRoundButton.style.display = "none";
    timeLeftSpan.textContent = timeLimit;
    
    if (gameMode === "number") {
      // Générer un nombre aléatoire dans la gamme choisie
      currentNumber = Math.floor(Math.random() * (maxNumber - minNumber + 1)) + minNumber;
      
      startMode1Round(currentNumber).then(() => {
        // Démarrer le timer (mise à jour toutes les 100 ms)
        startTime = new Date().getTime();
        clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 100);
      });
    } else if (gameMode === "time") {
      // Générer une heure aléatoire
      currentTime = generateRandomTime(timeStart, timeEnd);
      
      startTimeRound(currentTime).then(() => {
        // Démarrer le timer (mise à jour toutes les 100 ms)
        startTime = new Date().getTime();
        clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 100);
      });
    } else if (gameMode === "date") {
      // Générer une date aléatoire
      const dateObj = generateRandomDate(dateStart, dateEnd);
      currentDate = dateObj;
      
      startDateRound(currentDate).then(() => {
        // Démarrer le timer (mise à jour toutes les 100 ms)
        startTime = new Date().getTime();
        clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 100);
      });
    }
  }
  
  // Générer une heure aléatoire dans la plage
  function generateRandomTime(start, end) {
    const startDate = new Date(`2000-01-01T${start}`);
    const endDate = new Date(`2000-01-01T${end}`);
    
    // Si l'heure de fin est antérieure à l'heure de début, supposer que c'est le jour suivant
    let dateEnd = endDate;
    if (endDate < startDate) {
      dateEnd = new Date(endDate);
      dateEnd.setDate(dateEnd.getDate() + 1);
    }
    
    const randomTime = new Date(startDate.getTime() + Math.random() * (dateEnd.getTime() - startDate.getTime()));
    
    // Format HH:MM
    const hours = String(randomTime.getHours()).padStart(2, '0');
    const minutes = String(randomTime.getMinutes()).padStart(2, '0');
    
    return `${hours}:${minutes}`;
  }

  // Générer une date aléatoire dans la plage
  function generateRandomDate(start, end) {
    const startDate = new Date(start);
    const endDate = new Date(end);
    
    const randomDate = new Date(startDate.getTime() + Math.random() * (endDate.getTime() - startDate.getTime()));
    
    const year = randomDate.getFullYear();
    const month = randomDate.getMonth(); // 0-11
    const day = randomDate.getDate();
    
    return { year, month, day, date: randomDate };
  }
  
  // Conversion de l'heure (HH:MM) en mots français
  function timeToFrench(timeStr) {
    const [hours, minutes] = timeStr.split(':').map(num => parseInt(num, 10));
    
    // Cas spéciaux : midi et minuit
    if (minutes === 0) {
      if (hours === 0 || hours === 24) {
        return "minuit";
      } else if (hours === 12) {
        return "midi";
      }
    }
    
    // Déterminer l'heure de référence et si on utilise le format "moins"
    let refHour = hours;
    let isApproachingNextHour = false;
    
    if (minutes > 40 && minutes < 60) {
      refHour = (hours + 1) % 24;
      isApproachingNextHour = true;
    }
    
    // Texte pour l'heure de référence
    let hourText = "";
    if (refHour === 0 || refHour === 24) {
      hourText = "minuit";
    } else if (refHour === 12) {
      hourText = "midi";
    } else {
      hourText = numberToFrench(refHour) + " heure" + (refHour > 1 ? "s" : "");
    }
    
    // Cas où les minutes sont 0
    if (minutes === 0) {
      return hourText;
    }
    
    // Expressions naturelles pour les minutes
    if (!isApproachingNextHour) {
      if (minutes === 15) {
        return `${hourText} et quart`;
      } else if (minutes === 30) {
        return `${hourText} et demie`;
      } else if (minutes === 45) {
        // Pour 45 minutes, on utilise généralement "moins le quart" pour l'heure suivante
        const nextHour = (hours + 1) % 24;
        if (nextHour === 0 || nextHour === 24) {
          return "minuit moins le quart";
        } else if (nextHour === 12) {
          return "midi moins le quart";
        } else {
          return `${numberToFrench(nextHour)} heure${nextHour > 1 ? "s" : ""} moins le quart`;
        }
      } else {
        return `${hourText} ${numberToFrench(minutes)}`;
      }
    } else {
      // Format "moins" pour les heures approchant l'heure suivante
      const minutesToNextHour = 60 - minutes;
      if (minutesToNextHour === 5) {
        return `${hourText} moins cinq`;
      } else if (minutesToNextHour === 10) {
        return `${hourText} moins dix`;
      } else {
        return `${hourText} moins ${numberToFrench(minutesToNextHour)}`;
      }
    }
  }

  // Conversion de la date en mots français
  function dateToFrench(dateObj) {
    const months = [
      "janvier", "février", "mars", "avril", "mai", "juin",
      "juillet", "août", "septembre", "octobre", "novembre", "décembre"
    ];
    
    const day = dateObj.day;
    const month = months[dateObj.month];
    const year = dateObj.year;
    
    return `le ${numberToFrench(day)} ${month} ${numberToFrench(year)}`;
  }
  
  // Mode unique : L'utilisateur écoute le nombre et doit le taper (en chiffres)
  function startMode1Round(num) {
    // Fonction pour lancer la synthèse vocale
    function speakAudio() {
      let text = numberToFrench(num);
      const API_URL = ["127.0.0.1", "localhost"].indexOf(window.location.hostname) !== -1
        ? "http://localhost:8000"
        : "https://apt-retina-450420-j4.ue.r.appspot.com/"
      let audio = new Audio(`${API_URL}/tts?text=${encodeURIComponent(text)}`);
      return audio.play().catch(() => {
        // Sinon, utiliser la synthèse vocale native du navigateur
        let utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = "fr-FR";
        if (speechSynthesis.getVoices().length === 0) {
          speechSynthesis.onvoiceschanged = function() {
              speechSynthesis.speak(utterance);
              speechSynthesis.onvoiceschanged = null;
          };
        } else {
          speechSynthesis.speak(utterance);
        }
      });
    }

    challengeDiv.textContent = "Écoutez le nombre et tapez-le (en chiffres) :";
    inputAreaDiv.innerHTML = `
      <input type="number" id="userAnswer" autofocus autocomplete="off">
      <button id="replayAudio">Réécouter</button>
      <button id="submitAnswer">Valider</button>
    `;
    
    // Bouton pour réécouter l'audio
    document.getElementById("replayAudio").addEventListener("click", function() {
      speakAudio();
    });
    
    // Bouton pour valider manuellement la réponse
    document.getElementById("submitAnswer").addEventListener("click", function() {
      processMode1Answer();
    });
    
    // Validation automatique dès que la bonne réponse est saisie
    const answerInput = document.getElementById("userAnswer");
    answerInput.addEventListener("input", function() {
      if (!answerSubmitted && answerInput.value.trim() === currentNumber.toString()) {
        processMode1Answer();
      }
    });
    
    // Validation via la touche "Entrée"
    answerInput.addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        processMode1Answer();
      }
    });
    
    // Lecture initiale de l'audio
    return speakAudio();
  }
  
  // Mode d'écoute et de saisie de l'heure
  function startTimeRound(timeStr) {
    function speakTime() {
      let text = timeToFrench(timeStr);
      const API_URL = ["127.0.0.1", "localhost"].indexOf(window.location.hostname) !== -1
        ? "http://localhost:8000"
        : "https://apt-retina-450420-j4.ue.r.appspot.com/"
      let audio = new Audio(`${API_URL}/tts?text=${encodeURIComponent(text)}`);
      return audio.play().catch(() => {
        // Utiliser la synthèse vocale native du navigateur
        let utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = "fr-FR";
        if (speechSynthesis.getVoices().length === 0) {
          speechSynthesis.onvoiceschanged = function() {
              speechSynthesis.speak(utterance);
              speechSynthesis.onvoiceschanged = null;
          };
        } else {
          speechSynthesis.speak(utterance);
        }
      });
    }

    challengeDiv.textContent = "Écoutez l'heure et tapez-la (format 12h sans AM/PM, ex: 2:30) :";
    inputAreaDiv.innerHTML = `
      <input type="text" id="userAnswer" placeholder="h:mm" autofocus autocomplete="off">
      <button id="replayAudio">Réécouter</button>
      <button id="submitAnswer">Valider</button>
    `;
    
    // Bouton pour réécouter l'audio
    document.getElementById("replayAudio").addEventListener("click", function() {
      speakTime();
    });
    
    // Bouton pour valider la réponse
    document.getElementById("submitAnswer").addEventListener("click", function() {
      processTimeAnswer();
    });
    
    // Validation automatique en temps réel
    const answerInput = document.getElementById("userAnswer");
    answerInput.addEventListener("input", function() {
      // Convertir le format 24h en format 12h pour la comparaison
      const [hours24, minutes] = currentTime.split(':').map(num => parseInt(num, 10));
      const hours12 = hours24 % 12 === 0 ? 12 : hours24 % 12;
      const expectedAnswer = `${hours12}:${minutes.toString().padStart(2, '0')}`;
      
      // Normaliser la réponse de l'utilisateur
      let normalizedAnswer = answerInput.value.trim();
      if (normalizedAnswer.includes(':')) {
        const [h, m] = normalizedAnswer.split(':');
        if (m && m.length === 1) {
          normalizedAnswer = `${h}:0${m}`;
        }
      }
      
      // Vérifier si la réponse est correcte
      if (!answerSubmitted && normalizedAnswer === expectedAnswer) {
        processTimeAnswer();
      }
    });
    
    // Validation via la touche "Entrée"
    answerInput.addEventListener("keydown", function(e) {
      if (e.key === "Enter") {
        processTimeAnswer();
      }
    });
    
    // Lecture initiale de l'audio
    return speakTime();
  }

  // Mode d'écoute et de sélection de la date
  function startDateRound(dateObj) {
    let audioPlayCount = 0;
    const maxAudioPlays = 2;
    
    function speakDate() {
      if (audioPlayCount >= maxAudioPlays) {
        document.getElementById('listen-button').disabled = true;
        return Promise.resolve();
      }
      
      audioPlayCount++;
      
      // Update button text with play count
      const listenButton = document.getElementById('listen-button');
      if (audioPlayCount === maxAudioPlays) {
        listenButton.textContent = "Écouter (0 restant)";
        listenButton.disabled = true;
      } else {
        listenButton.textContent = `Écouter (${maxAudioPlays - audioPlayCount} restant)`;
      }
      
      let text = dateToFrench(dateObj);
      const API_URL = ["127.0.0.1", "localhost"].indexOf(window.location.hostname) !== -1
        ? "http://localhost:8000"
        : "https://apt-retina-450420-j4.ue.r.appspot.com/"
      let audio = new Audio(`${API_URL}/tts?text=${encodeURIComponent(text)}`);
      return audio.play().catch(() => {
        // Utiliser la synthèse vocale native du navigateur
        let utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = "fr-FR";
        if (speechSynthesis.getVoices().length === 0) {
          speechSynthesis.onvoiceschanged = function() {
              speechSynthesis.speak(utterance);
              speechSynthesis.onvoiceschanged = null;
          };
        } else {
          speechSynthesis.speak(utterance);
        }
      });
    }

    challengeDiv.textContent = "Écoutez la date :";
    
    // First, just show the listen button
    inputAreaDiv.innerHTML = `
      <div id="audio-controls">
        <button id="listen-button">Écouter (${maxAudioPlays} restants)</button>
        <button id="show-options-button" style="display:none;">Afficher les options</button>
      </div>
    `;
    
    // Add event listener for the listen button
    document.getElementById("listen-button").addEventListener("click", function() {
      speakDate().then(() => {
        document.getElementById("show-options-button").style.display = "inline-block";
      });
    });
    
    // Add event listener for the show options button
    document.getElementById("show-options-button").addEventListener("click", function() {
      // Generate options for day, month, and year - reduced to 4 options each
      const dayOptions = generateDateOptions(dateObj, 'day', 4);
      const monthOptions = generateDateOptions(dateObj, 'month', 4);
      const yearOptions = generateDateOptions(dateObj, 'year', 4);
      
      // Update challenge text
      challengeDiv.textContent = "Sélectionnez les bonnes options pour la date que vous avez entendue :";
      
      // Replace the audio controls with the multiple choice interface
      inputAreaDiv.innerHTML = `
        <div class="date-selector">
          <div class="date-column">
            <h3>Jour</h3>
            <div class="options-container day-options">
              ${generateOptionButtons(dayOptions, 'day')}
            </div>
          </div>
          <div class="date-column">
            <h3>Mois</h3>
            <div class="options-container month-options">
              ${generateOptionButtons(monthOptions, 'month')}
            </div>
          </div>
          <div class="date-column">
            <h3>Année</h3>
            <div class="options-container year-options">
              ${generateOptionButtons(yearOptions, 'year')}
            </div>
          </div>
        </div>
      `;
      
      // Event listeners for the option buttons
      document.querySelectorAll('.date-option').forEach(button => {
        button.addEventListener('click', function() {
          // Remove selected class from other options in the same category
          const category = this.getAttribute('data-category');
          document.querySelectorAll(`.date-option[data-category="${category}"]`).forEach(btn => {
            btn.classList.remove('selected');
          });
          
          // Add selected class to the clicked button
          this.classList.add('selected');
          
          // Check if all categories have been selected
          const daySelected = document.querySelector('.date-option[data-category="day"].selected');
          const monthSelected = document.querySelector('.date-option[data-category="month"].selected');
          const yearSelected = document.querySelector('.date-option[data-category="year"].selected');
          
          // If all three components are selected, automatically validate
          if (daySelected && monthSelected && yearSelected) {
            // Give a slight delay to show the selection before processing
            setTimeout(() => {
              processDateAnswer(dateObj);
            }, 300);
          }
        });
      });
      
      // Start the timer only when options are shown
      startTime = new Date().getTime();
      clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 100);
    });
    
    return Promise.resolve(); // We don't auto-play the audio anymore
  }
  
  // Function to generate HTML for option buttons
  function generateOptionButtons(options, category) {
    return options.map(option => {
      const displayValue = category === 'month' 
        ? getMonthName(option.value - 1) // Convert 1-based to 0-based for month names
        : option.value.toString();
      
      return `
        <button class="date-option" data-category="${category}" data-value="${option.value}" data-correct="${option.correct}">
          ${displayValue}
        </button>
      `;
    }).join('');
  }
  
  // Get the French month name
  function getMonthName(monthIndex) {
    const months = [
      "janvier", "février", "mars", "avril", "mai", "juin",
      "juillet", "août", "septembre", "octobre", "novembre", "décembre"
    ];
    return months[monthIndex];
  }

  // Traitement de la réponse pour le mode date
  function processDateAnswer(dateObj) {
    if (answerSubmitted) return;
    answerSubmitted = true;
    clearInterval(timerInterval);
    let elapsed = (new Date().getTime() - startTime) / 1000;
    let points = 0;
    let correct = false;
    
    // Get user's selected values
    const selectedDay = document.querySelector('.date-option[data-category="day"].selected')?.getAttribute('data-value');
    const selectedMonth = document.querySelector('.date-option[data-category="month"].selected')?.getAttribute('data-value');
    const selectedYear = document.querySelector('.date-option[data-category="year"].selected')?.getAttribute('data-value');
    
    // Convert to integers for comparison
    const dayValue = selectedDay ? parseInt(selectedDay) : null;
    const monthValue = selectedMonth ? parseInt(selectedMonth) : null;
    const yearValue = selectedYear ? parseInt(selectedYear) : null;
    
    // Check if all selections are correct
    if (dayValue === dateObj.day && 
        monthValue === dateObj.month + 1 && 
        yearValue === dateObj.year) {
      correct = true;
      points = Math.round((timeLimit - elapsed) * 10);
      feedbackDiv.textContent = "Correct ! +" + points + " points.";
      totalScore += points;
    } else {
      const months = [
        "janvier", "février", "mars", "avril", "mai", "juin",
        "juillet", "août", "septembre", "octobre", "novembre", "décembre"
      ];
      feedbackDiv.textContent = `Incorrect. La bonne réponse était : ${dateObj.day} ${months[dateObj.month]} ${dateObj.year}`;
    }
    
    totalScoreSpan.textContent = totalScore;
    disableInput();
    
    // Enregistrer le résultat du tour
    roundResults.push({
      round: round,
      challenge: `${dateObj.day}/${dateObj.month + 1}/${dateObj.year}`,
      correct: correct,
      elapsed: parseFloat(elapsed.toFixed(2)),
      points: points,
      answer: selectedDay && selectedMonth && selectedYear ? 
              `${dayValue}/${monthValue}/${yearValue}` : "Incomplet"
    });
    
    nextRoundButton.style.display = "inline-block";
    // Add the event listener for Enter key
    document.addEventListener("keydown", handleNextRoundKeyPress);
  }
  
  // Traitement de la réponse pour le mode heure
  function processTimeAnswer() {
    if (answerSubmitted) return;
    answerSubmitted = true;
    clearInterval(timerInterval);
    const answerInput = document.getElementById("userAnswer");
    let userAnswer = answerInput.value.trim();
    let elapsed = (new Date().getTime() - startTime) / 1000;
    let points = 0;
    let correct = false;
    
    // Convertir le format 24h en format 12h pour la comparaison
    const [hours24, minutes] = currentTime.split(':').map(num => parseInt(num, 10));
    const hours12 = hours24 % 12 === 0 ? 12 : hours24 % 12;
    const expectedAnswer = `${hours12}:${minutes.toString().padStart(2, '0')}`;
    
    // Normaliser la réponse de l'utilisateur (ajouter des zéros aux minutes si nécessaire)
    let normalizedAnswer = userAnswer;
    if (userAnswer.includes(':')) {
      const [h, m] = userAnswer.split(':');
      if (m.length === 1) {
        normalizedAnswer = `${h}:0${m}`;
      }
    }
    
    if (normalizedAnswer === expectedAnswer) {
      correct = true;
      points = Math.round((timeLimit - elapsed) * 10);
      feedbackDiv.textContent = "Correct ! +" + points + " points.";
      totalScore += points;
    } else {
      feedbackDiv.textContent = `Incorrect. La bonne réponse était : ${expectedAnswer} (${hours24}:${minutes.toString().padStart(2, '0')})`;
    }
    totalScoreSpan.textContent = totalScore;
    disableInput();
    
    // Enregistrer le résultat du tour
    roundResults.push({
      round: round,
      challenge: currentTime,
      correct: correct,
      elapsed: parseFloat(elapsed.toFixed(2)),
      points: points,
      answer: userAnswer,
      expectedAnswer: expectedAnswer
    });
    
    nextRoundButton.style.display = "inline-block";
    // Add the event listener for Enter key
    document.addEventListener("keydown", handleNextRoundKeyPress);
  }
  
  // Traitement de la réponse en mode 1
  function processMode1Answer() {
    if (answerSubmitted) return; // Empêche une double validation
    answerSubmitted = true;
    clearInterval(timerInterval);
    const answerInput = document.getElementById("userAnswer");
    let userAnswer = answerInput.value.trim();
    let elapsed = (new Date().getTime() - startTime) / 1000;
    let points = 0;
    let correct = false;
    if (userAnswer === currentNumber.toString()) {
      correct = true;
      points = Math.round((timeLimit - elapsed) * 10);
      feedbackDiv.textContent = "Correct ! +" + points + " points.";
      totalScore += points;
    } else {
      feedbackDiv.textContent = "Incorrect. La bonne réponse était : " + currentNumber;
    }
    totalScoreSpan.textContent = totalScore;
    disableInput();
    
    // Enregistrer le résultat du tour
    roundResults.push({
      round: round,
      number: currentNumber,
      correct: correct,
      elapsed: parseFloat(elapsed.toFixed(2)),
      points: points,
      answer: userAnswer
    });
    
    nextRoundButton.style.display = "inline-block";
    // Add the event listener for Enter key
    document.addEventListener("keydown", handleNextRoundKeyPress);
  }
  
  // Mise à jour du timer et vérification de la limite de temps
  function updateTimer() {
    let elapsed = (new Date().getTime() - startTime) / 1000;
    let remaining = (timeLimit - elapsed).toFixed(1);
    timeLeftSpan.textContent = remaining;
    if (elapsed >= timeLimit) {
      clearInterval(timerInterval);
      if (gameMode === "number") {
        feedbackDiv.textContent = "Temps écoulé ! La bonne réponse était : " + currentNumber;
        // Enregistrer le résultat en cas d'échec (temps écoulé)
        roundResults.push({
          round: round,
          number: currentNumber,
          correct: false,
          elapsed: timeLimit,
          points: 0,
          answer: ""
        });
      } else if (gameMode === "time") {
        const [hours24, minutes] = currentTime.split(':').map(num => parseInt(num, 10));
        const hours12 = hours24 % 12 === 0 ? 12 : hours24 % 12;
        const expectedAnswer = `${hours12}:${minutes.toString().padStart(2, '0')}`;
        feedbackDiv.textContent = `Temps écoulé ! La bonne réponse était : ${expectedAnswer} (${hours24}:${minutes.toString().padStart(2, '0')})`;
        roundResults.push({
          round: round,
          challenge: currentTime,
          correct: false,
          elapsed: timeLimit,
          points: 0,
          answer: ""
        });
      } else if (gameMode === "date") {
        const months = [
          "janvier", "février", "mars", "avril", "mai", "juin",
          "juillet", "août", "septembre", "octobre", "novembre", "décembre"
        ];
        feedbackDiv.textContent = `Temps écoulé ! La bonne réponse était : ${currentDate.day} ${months[currentDate.month]} ${currentDate.year}`;
        roundResults.push({
          round: round,
          challenge: `${currentDate.day}/${currentDate.month + 1}/${currentDate.year}`,
          correct: false,
          elapsed: timeLimit,
          points: 0,
          answer: ""
        });
      }
      disableInput();
      nextRoundButton.style.display = "inline-block";
      // Add the event listener for Enter key
      document.addEventListener("keydown", handleNextRoundKeyPress);
    }
  }
  
  // Désactiver les champs de saisie
  function disableInput() {
    let inputs = inputAreaDiv.getElementsByTagName("input");
    for (let input of inputs) {
      input.disabled = true;
    }
    let buttons = inputAreaDiv.querySelectorAll("button:not(#nextRoundButton)");
    for (let button of buttons) {
      button.disabled = true;
    }
  }
  
  // Bouton "Suivant" pour passer au tour suivant
  nextRoundButton.addEventListener("click", nextRound);

  // Global handler for pressing Enter to advance to next round
  function handleNextRoundKeyPress(e) {
    if (e.key === "Enter" && nextRoundButton.style.display === "inline-block") {
      nextRound();
    }
  }
  
  // Fin de partie : affichage du score final, du détail de chaque tour et bouton de partage
  function gameOver() {
    clearInterval(timerInterval);
    gameDiv.style.display = "none";
    resultDiv.style.display = "block";
    let html = `<h2>Partie terminée ! Votre score final est : ${totalScore}</h2>`;
    html += `<h3>Détails des tours :</h3>`;
    html += `<table>
               <tr>
                 <th>${gameMode === "number" ? "Nombre" : (gameMode === "time" ? "Heure" : "Date")}</th>
                 <th>Temps (s)</th>
                 <th>Points</th>
               </tr>`;
    roundResults.forEach(result => {
      const challenge = gameMode === "number" ? result.number : result.challenge;
      html += `<tr>
                 <td>${challenge}</td>
                 <td>${result.correct ? result.elapsed : '-'}</td>
                 <td>${result.correct ? result.points : 0}</td>
               </tr>`;
    });
    html += `</table>`;
    html += `<button onclick="restartGame()">Rejouer</button>`;
    html += `<button onclick="shareScore()" style="margin-left:10px;">Partager mon score</button>`;
    resultDiv.innerHTML = html;
  }
  
  function restartGame() {
    menuDiv.style.display = "block";
    gameDiv.style.display = "none";
    resultDiv.style.display = "none";
  }
  
  // Fonction pour partager le score
  function shareScore() {
    const shareText = `J'ai obtenu ${totalScore} points dans le Jeu de Numéros Français ! Peux-tu faire mieux ? Essaye-le ici : ${window.location.href}`;
    if (navigator.share) {
      navigator.share({
        title: "Jeu de Numéros Français",
        text: shareText,
        url: window.location.href
      })
      .then(() => console.log('Score partagé avec succès'))
      .catch((error) => console.log('Erreur de partage', error));
    } else {
      copyTextToClipboard(shareText);
      alert("Votre score a été copié dans le presse-papier !");
    }
  }
  
  // Fonction utilitaire pour copier du texte dans le presse-papier
  function copyTextToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      document.execCommand('copy');
    } catch (err) {
      console.error('Erreur lors de la copie', err);
    }
    document.body.removeChild(textArea);
  }
  
  // --- Fonctions d'aide pour la conversion d'un nombre en toutes lettres en français ---
  function numberToFrench(n) {
    if (n < 0) return n.toString();
    if (n < 1000) {
      return convertHundreds(n);
    } else if (n < 10000) {
      let thousands = Math.floor(n / 1000);
      let remainder = n % 1000;
      let result = "";
      if (thousands === 1)
        result = "mille";
      else
        result = convertHundreds(thousands) + " mille";
      if (remainder > 0)
        result += " " + convertHundreds(remainder);
      return result;
    } else {
      return n.toString();
    }
  }
  
  function convertHundreds(n) {
    const ones = ["zéro", "un", "deux", "trois", "quatre", "cinq", "six", "sept", "huit", "neuf", "dix", "onze", "douze", "treize", "quatorze", "quinze", "seize"];
    if (n < 17) return ones[n];
    if (n < 20) return "dix-" + ones[n - 10];
    if (n < 70) {
      let tens = Math.floor(n / 10);
      let unit = n % 10;
      const tensWords = ["", "", "vingt", "trente", "quarante", "cinquante", "soixante"];
      let word = tensWords[tens];
      if (unit === 1) {
        word += " et un";
      } else if (unit > 0) {
        word += "-" + ones[unit];
      }
      return word;
    }
    if (n < 80) {
      if (n === 71) return "soixante et onze";
      return "soixante-" + convertHundreds(n - 60);
    }
    if (n < 100) {
      let unit = n - 80;
      let word = "quatre-vingt";
      if (unit === 0) {
        word += "s";
      } else {
        word += "-" + convertHundreds(unit);
      }
      return word;
    }
    if (n < 200) {
      if (n === 100) return "cent";
      else return "cent " + convertHundreds(n - 100);
    }
    if (n < 1000) {
      let hundreds = Math.floor(n / 100);
      let remainder = n % 100;
      let word = convertHundreds(hundreds) + " cent";
      if (remainder === 0 && hundreds > 1) {
        word += "s";
      } else if (remainder > 0) {
        word += " " + convertHundreds(remainder);
      }
      return word;
    }
  }

  // Generate date component options (including the correct one and some distractors)
  function generateDateOptions(dateObj, component, count) {
    const options = [];
    let correctValue;
    
    // Get the correct value
    if (component === 'day') {
      correctValue = dateObj.day;
    } else if (component === 'month') {
      correctValue = dateObj.month + 1; // Adjust for 0-based month
    } else { // year
      correctValue = dateObj.year;
    }
    
    // Add the correct option
    options.push({ value: correctValue, correct: true });
    
    // Generate distractor options
    const range = component === 'year' ? 100 : (component === 'month' ? 12 : 31);
    const min = component === 'year' ? 1900 : (component === 'month' ? 1 : 1);
    const max = component === 'year' ? 2050 : (component === 'month' ? 12 : 31);
    
    while (options.length < count) {
      let randomValue;
      if (component === 'year') {
        // For years, generate values close to the correct year
        randomValue = correctValue + Math.floor(Math.random() * 20) - 10;
        if (randomValue < min) randomValue = min;
        if (randomValue > max) randomValue = max;
      } else {
        randomValue = Math.floor(Math.random() * range) + min;
      }
      
      // Make sure we don't add duplicates
      if (!options.some(option => option.value === randomValue)) {
        options.push({ value: randomValue, correct: false });
      }
    }
    
    // Shuffle the options
    return options.sort(() => Math.random() - 0.5);
  }
</script>
</body>
</html>